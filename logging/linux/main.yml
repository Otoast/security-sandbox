---
################################################################################
# CONTROL INSTANCE SETUP - ELASTICSEARCH + KIBANA + FLEET SERVER
################################################################################
#
# Purpose:
#   Sets up the centralized logging and monitoring server (control machine)
#   for the security sandbox lab. This machine collects metrics from target
#   machines and displays them to the attacker machine via Kibana.
#
# Architecture:
#   Control Machine (This playbook)
#   ├── Elasticsearch (Port 9200) - Log storage and search engine
#   ├── Kibana (Port 5601) - Web UI for SIEM visualization
#   └── Fleet Server (Port 8220) - Manages Elastic Agents on targets
#
# Prerequisites:
#   - Linux EC2 instance (Amazon Linux 2023 or similar)
#   - Minimum 4GB RAM (t3.medium recommended)
#   - Runs in PRIVATE subnet (no internet access)
#   - Accessible via SSH from attacker machine only
#   - Installation files pre-downloaded on attacker machine (see download_files.yml)
#
# Network Architecture:
#   - Control machine is in PRIVATE subnet (no internet gateway)
#   - Files are downloaded by attacker machine (public subnet)
#   - Ansible copies files from attacker → control machine via SSH/SCP
#
# Security:
#   - Uses Elasticsearch built-in security (auto-generated passwords)
#   - Fleet Server uses service tokens for authentication
#   - All credentials saved locally for target machine enrollment
#
# Usage:
#   1. FIRST: Run download_files.yml on attacker machine to get installation files
#   2. Update logging_server.ini with control instance IP
#   3. Run: ansible-playbook -i logging_server.ini main.yml
#   4. Save displayed credentials for target machine deployment
#
# Output:
#   - Credentials file: .fleet_credentials.yml (in playbook directory)
#   - Used by target machine playbook for automatic agent enrollment
#
# Estimated Runtime: 15-20 minutes
#
################################################################################

- name: Control Machine Setup - ELK Stack with Fleet Server
  hosts: logging_server
  become: yes
  vars:
    elastic_version: "8.11.0"
    elasticsearch_dir: "/opt/elasticsearch-{{ elastic_version }}"
    kibana_dir: "/opt/kibana-{{ elastic_version }}"
    # Path to pre-downloaded files on the Ansible control machine (attacker)
    local_files_dir: "{{ playbook_dir }}/../../downloads"

  tasks:
    ############################################################################
    # PHASE 1: SYSTEM PREPARATION
    ############################################################################
    
    - name: Set kernel parameters for Elasticsearch
      sysctl:
        name: vm.max_map_count
        value: '262144'
        state: present
        reload: yes
      # Required for Elasticsearch to run properly

    - name: Ensure installation directory exists
      file:
        path: /opt
        state: directory
        mode: '0755'

    ############################################################################
    # PHASE 2: ELASTICSEARCH INSTALLATION
    ############################################################################
    
    - name: Copy Elasticsearch to control machine
      copy:
        src: "{{ local_files_dir }}/elasticsearch-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/elasticsearch.tar.gz"
      # Copies pre-downloaded file from attacker machine to control machine
      
    - name: Extract Elasticsearch
      unarchive:
        src: "/tmp/elasticsearch.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "{{ elasticsearch_dir }}"

    - name: Configure Elasticsearch
      blockinfile:
        path: "{{ elasticsearch_dir }}/config/elasticsearch.yml"
        block: |
          cluster.name: security-sandbox-cluster
          node.name: control-node
          network.host: 0.0.0.0
          http.port: 9200
          discovery.type: single-node
          xpack.security.enabled: true
          xpack.security.enrollment.enabled: true
        marker: "# {mark} ANSIBLE MANAGED BLOCK"
      # Security enabled with enrollment tokens for Kibana/Fleet

    - name: Create Elasticsearch systemd service
      copy:
        dest: /etc/systemd/system/elasticsearch.service
        content: |
          [Unit]
          Description=Elasticsearch
          Documentation=https://www.elastic.co
          After=network.target
          
          [Service]
          Type=simple
          User=elasticsearch
          Group=elasticsearch
          ExecStart={{ elasticsearch_dir }}/bin/elasticsearch
          StandardOutput=journal
          StandardError=journal
          LimitNOFILE=65535
          LimitNPROC=4096
          LimitMEMLOCK=infinity
          TimeoutStopSec=0
          KillSignal=SIGTERM
          KillMode=process
          SendSIGKILL=no
          SuccessExitStatus=143
          Restart=on-failure
          RestartSec=10s
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'
    
    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes
    
    - name: Start Elasticsearch service
      systemd:
        name: elasticsearch
        state: started
        enabled: yes
    
    - name: Wait for Elasticsearch to be ready
      wait_for:
        port: 9200
        delay: 20
        timeout: 300
    
    - name: Additional wait for Elasticsearch startup
      pause:
        seconds: 10
    
    - name: Reset elastic user password
      command: "{{ elasticsearch_dir }}/bin/elasticsearch-reset-password -u elastic -b"
      register: elastic_password_output
    
    - name: Extract elastic password
      set_fact:
        elastic_password: "{{ elastic_password_output.stdout | regex_search('New value: (.+)', '\\1') | first }}"
    
    - name: Display elastic password
      debug:
        msg: "Elasticsearch 'elastic' user password: {{ elastic_password }}"

    ############################################################################
    # PHASE 3: KIBANA INSTALLATION
    ############################################################################
    
    - name: Copy Kibana to control machine
      copy:
        src: "{{ local_files_dir }}/kibana-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/kibana.tar.gz"
      # Copies pre-downloaded file from attacker machine to control machine
      
    - name: Extract Kibana
      unarchive:
        src: "/tmp/kibana.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "{{ kibana_dir }}"

    - name: Configure Kibana
      blockinfile:
        path: "{{ kibana_dir }}/config/kibana.yml"
        block: |
          server.host: "0.0.0.0"
          server.port: 5601
          elasticsearch.hosts: ["http://localhost:9200"]
          elasticsearch.serviceAccountToken: "{{ kibana_service_token.json.token.value if kibana_service_token is defined else '' }}"
        marker: "# {mark} ANSIBLE MANAGED BLOCK"
    
    - name: Create Kibana systemd service
      copy:
        dest: /etc/systemd/system/kibana.service
        content: |
          [Unit]
          Description=Kibana
          Documentation=https://www.elastic.co
          After=network.target elasticsearch.service
          
          [Service]
          Type=simple
          User=kibana
          Group=kibana
          ExecStart={{ kibana_dir }}/bin/kibana
          StandardOutput=journal
          StandardError=journal
          Restart=on-failure
          RestartSec=10s
          
          [Install]
          WantedBy=multi-user.target
        mode: '0644'
    
    - name: Create Kibana service token if needed (cleanup existing)
      uri:
        url: "http://localhost:9200/_security/service/elastic/kibana/credential"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: existing_tokens
      failed_when: false
    
    - name: Delete existing Kibana token if present
      uri:
        url: "http://localhost:9200/_security/service/elastic/kibana/credential/token/kibana-token"
        method: DELETE
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: [200, 404]
      when: existing_tokens.json['tokens'] is defined and ('kibana-token' in existing_tokens.json['tokens'])
      failed_when: false
    
    - name: Create Kibana service account token
      uri:
        url: "http://localhost:9200/_security/service/elastic/kibana/credential/token/kibana-token"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: kibana_service_token
    
    - name: Reload systemd daemon for Kibana
      systemd:
        daemon_reload: yes
    
    - name: Restart Kibana service
      systemd:
        name: kibana
        state: restarted
        enabled: yes
    
    - name: Wait for Kibana to be ready
      wait_for:
        port: 5601
        delay: 30
        timeout: 300

    ############################################################################
    # PHASE 4: FLEET SERVER INSTALLATION
    ############################################################################
    
    - name: Enable Fleet in Kibana
      uri:
        url: "http://localhost:5601/api/fleet/setup"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        status_code: 200
        return_content: yes
      register: fleet_setup
      failed_when: false
    
    - name: Wait for Fleet to initialize
      pause:
        seconds: 10
    
    - name: Get Fleet Server policy
      uri:
        url: "http://localhost:5601/api/fleet/agent_policies"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
        status_code: 200
        return_content: yes
      register: fleet_policies
      retries: 10
      delay: 10
      until: fleet_policies.status == 200
    
    - name: Set default policy facts
      set_fact:
        fleet_server_policy_exists: false
        fleet_server_policy_id: ""
    
    - name: Find Fleet Server policy
      set_fact:
        fleet_server_policy_exists: true
        fleet_server_policy_id: "{{ item.id }}"
      loop: "{{ fleet_policies.json['items'] | default([]) }}"
      when:
        - fleet_policies.json['items'] is defined
        - item.name is defined
        - item.name == 'Fleet Server policy'
    
    - name: Create Fleet Server policy if it doesn't exist
      uri:
        url: "http://localhost:5601/api/fleet/agent_policies"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "Fleet Server policy"
          namespace: "default"
          description: "Fleet Server policy"
          monitoring_enabled:
            - logs
            - metrics
          has_fleet_server: true
        status_code: 200
        return_content: yes
      register: fleet_server_policy_created
      when: not fleet_server_policy_exists
    
    - name: Get Fleet Server policy ID
      set_fact:
        fleet_server_policy_id: "{{ (fleet_policies.json['items'] | selectattr('name', 'equalto', 'Fleet Server policy') | list | first).id if fleet_server_policy_exists else fleet_server_policy_created.json.item.id }}"
    
    - name: Add Fleet Server integration to policy
      uri:
        url: "http://localhost:5601/api/fleet/package_policies"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "fleet_server-1"
          namespace: "default"
          policy_id: "{{ fleet_server_policy_id }}"
          enabled: true
          package:
            name: "fleet_server"
            version: "1.5.0"
          inputs:
            - type: "fleet-server"
              enabled: true
              streams: []
              vars:
                host:
                  value: "0.0.0.0"
                  type: "text"
                port:
                  value: 8220
                  type: "integer"
                custom: ""
        status_code: [200, 409]
        return_content: yes
      register: fleet_server_integration
      failed_when: false
    
    - name: Check if Fleet service token exists
      uri:
        url: "http://localhost:9200/_security/service/elastic/fleet-server/credential"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: existing_fleet_tokens
      failed_when: false
    
    - name: Delete existing Fleet token if present
      uri:
        url: "http://localhost:9200/_security/service/elastic/fleet-server/credential/token/fleet-token"
        method: DELETE
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: [200, 404]
      when: existing_fleet_tokens.json['tokens'] is defined and ('fleet-token' in existing_fleet_tokens.json['tokens'])
      failed_when: false
    
    - name: Create Fleet service token
      uri:
        url: "http://localhost:9200/_security/service/elastic/fleet-server/credential/token/fleet-token"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: fleet_service_token

    - name: Copy Elastic Agent TAR from controller (offline)
      copy:
        src: "{{ local_files_dir }}/elastic-agent-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/elastic-agent.tar.gz"
        mode: '0644'
      # Copies pre-downloaded Elastic Agent from the attacker/controller to the control host

    - name: Extract Elastic Agent
      unarchive:
        src: "/tmp/elastic-agent.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "/opt/elastic-agent-{{ elastic_version }}-linux-x86_64"
      # Idempotent: will skip extraction if the directory already exists
    
    - name: Install Fleet Server
      shell: |
        cd /opt/elastic-agent-{{ elastic_version }}-linux-x86_64
        ./elastic-agent install \
          --url=http://localhost:5601 \
          --fleet-server-es=http://localhost:9200 \
          --fleet-server-service-token={{ fleet_service_token.json.token.value }} \
          --fleet-server-policy={{ fleet_server_policy_id }} \
          --fleet-server-insecure-http \
          --non-interactive
      args:
        creates: /opt/Elastic/Agent/elastic-agent
    
    - name: Wait for Fleet Server to be ready
      wait_for:
        port: 8220
        delay: 10
        timeout: 180
    
    - name: Get Fleet enrollment API key list
      uri:
        url: "http://localhost:5601/api/fleet/enrollment_api_keys"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
        status_code: 200
        return_content: yes
      register: existing_enrollment_keys
      failed_when: false
    
    - name: Set default enrollment facts
      set_fact:
        fleet_enrollment_token: ""
        fleet_enrollment_key_found: false
    
    - name: Find existing enrollment key for policy
      set_fact:
        fleet_enrollment_token: "{{ item.api_key }}"
        fleet_enrollment_key_found: true
      loop: "{{ existing_enrollment_keys.json['list'] | default([]) }}"
      when:
        - item.name is defined
        - item.policy_id is defined
        - "'auto-enroll' in item.name"
        - item.policy_id == fleet_server_policy_id
    
    - name: Create Fleet enrollment API key if missing
      uri:
        url: "http://localhost:5601/api/fleet/enrollment_api_keys"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "auto-enroll"
          policy_id: "{{ fleet_server_policy_id }}"
          expiration: "1d"
        status_code: 200
        return_content: yes
      register: fleet_enrollment_response
      when: not fleet_enrollment_key_found
      failed_when: false
    
    - name: Set enrollment token from created key if created
      set_fact:
        fleet_enrollment_token: "{{ fleet_enrollment_response.json.item.api_key }}"
      when: fleet_enrollment_response is defined and fleet_enrollment_response.json.item.api_key is defined

    ############################################################################
    # PHASE 5: SAVE CREDENTIALS FOR TARGET MACHINES
    ############################################################################
    
    - name: Save Fleet credentials to local file
      local_action:
        module: copy
        content: |
          # Fleet Server Credentials for Target Machine Enrollment
          # Generated: {{ ansible_date_time.iso8601 }}
          # Control Server: {{ ansible_default_ipv4.address }}
          
          fleet_url: "https://{{ ansible_default_ipv4.address }}:8220"
          fleet_enrollment_token: "{{ fleet_enrollment_token }}"
          elasticsearch_host: "http://{{ ansible_default_ipv4.address }}:9200"
          elastic_username: "elastic"
          elastic_password: "{{ elastic_password }}"
          kibana_host: "http://{{ ansible_default_ipv4.address }}:5601"
          ca_fingerprint: "{{ es_ca_fingerprint.stdout }}"
        dest: "{{ playbook_dir }}/.fleet_credentials.yml"
      become: no

    - name: Display deployment summary
      debug:
        msg: |
          ============================================================
          CONTROL INSTANCE DEPLOYMENT COMPLETE
          ============================================================
          
          Services Running:
          - Elasticsearch: http://{{ ansible_default_ipv4.address }}:9200
          - Kibana:        http://{{ ansible_default_ipv4.address }}:5601
          - Fleet Server:  https://{{ ansible_default_ipv4.address }}:8220
          
          Credentials:
          - Username: elastic
          - Password: {{ elastic_password }}
          
          Fleet Enrollment Token:
          {{ fleet_enrollment_token }}
          
          Credentials saved to: {{ playbook_dir }}/.fleet_credentials.yml
          
          Next Steps:
          1. Access Kibana from attacker machine: http://{{ ansible_default_ipv4.address }}:5601
          2. Login with elastic/{{ elastic_password }}
          3. Deploy target machine with Elastic Agent using saved credentials
          4. Agents will auto-enroll to Fleet Server
          
          ============================================================

################################################################################
# DEPLOYMENT NOTES
################################################################################
#
# What's Installed:
# ├── Elasticsearch 8.11.0 - Search engine and data store
# ├── Kibana 8.11.0 - Web UI for SIEM and Fleet management  
# └── Fleet Server 8.11.0 - Agent enrollment and policy management
#
# Architecture Integration:
# - This is the CONTROL machine in the private subnet
# - Attacker machine connects to Kibana (5601) and Elasticsearch (9200)
# - Target machine connects to Fleet Server (8220) for agent enrollment
# - All security managed through Elasticsearch built-in security
#
# Security Groups Required:
# - Inbound 5601 from attacker-machine-SG (Kibana)
# - Inbound 9200 from attacker-machine-SG (Elasticsearch)
# - Inbound 8220 from target-machine-SG (Fleet Server)
# - Inbound 22 from attacker-machine-SG (SSH)
# - No outbound connections needed
#
# Resource Requirements:
# - Instance Type: t3.medium minimum (4GB RAM, 2 vCPUs)
# - Disk Space: ~10GB for installation + logs
# - Network: Private subnet, no internet gateway needed
#
# Troubleshooting:
# - Logs: /var/log/elasticsearch.log, /var/log/kibana.log
# - Check service status: systemctl status elastic-agent
# - Fleet Server logs: journalctl -u elastic-agent
# - Elasticsearch cluster health: curl http://localhost:9200/_cluster/health
#
################################################################################
