- name: Control Machine Setup - ELK Stack
  hosts: logging_server
  become: yes
  gather_facts: yes
  vars:
    elastic_version: "8.17.0"
    elasticsearch_dir: "/opt/elasticsearch-{{ elastic_version }}"
    kibana_dir: "/opt/kibana-{{ elastic_version }}"
    local_cache_dir: "{{ playbook_dir }}/downloads"
    kibana_base_url: "http://localhost:5601"
    kibana_request_timeout: 60
    fleet_api_retries: 10
    fleet_api_delay: 10
    package_registry_port: 8080

  tasks:
    ############################################################################
    # PHASE 1: SYSTEM PREPARATION AND DOWNLOADS (AMAZON LINUX 2023)
    ############################################################################
    
    - name: Update dnf cache (Amazon Linux 2023)
      dnf:
        update_cache: yes
      retries: 3
      delay: 5
      register: dnf_cache_update
      until: dnf_cache_update is succeeded

    - name: Install prerequisites (Amazon Linux 2023)
      dnf:
        name:
          - wget
          - curl
          - unzip
          - tar
        state: present
        allowerasing: true
      retries: 3
      delay: 5
      register: al2023_prereqs
      until: al2023_prereqs is succeeded

    
    - name: Install Docker (Amazon Linux 2023)
      ansible.builtin.shell: |
        set -e
        sudo dnf -y update
        sudo dnf -y install docker
      args:
        executable: /bin/bash
      register: install_docker
      retries: 3
      delay: 10
      until: install_docker is succeeded

    - name: Increase swap file
      ansible.builtin.shell: |
        sudo dd if=/dev/zero of=/swapfile bs=1M count=4096
        sudo chmod 600 /swapfile
        sudo mkswap /swapfile
        sudo swapon /swapfile
        echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
      args:
        executable: /bin/bash
      
    - name: Start and enable Docker
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Set kernel parameters for Elasticsearch
      sysctl:
        name: vm.max_map_count
        value: '262144'
        state: present
        reload: yes

    - name: Create elasticsearch system user
      user:
        name: elasticsearch
        system: yes
        shell: /bin/bash
        home: /opt/elasticsearch
        create_home: no

    - name: Create kibana system user
      user:
        name: kibana
        system: yes
        shell: /bin/bash
        home: /opt/kibana
        create_home: no

    ############################################################################
    # PHASE 2: ELASTICSEARCH INSTALLATION
    ############################################################################
    
    - name: Download Elasticsearch
      get_url:
        url: "https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/elasticsearch.tar.gz"
        timeout: 600
      
    - name: Extract Elasticsearch and set ownership
      unarchive:
        src: "/tmp/elasticsearch.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "{{ elasticsearch_dir }}"
        owner: elasticsearch
        group: elasticsearch

    - name: Configure Elasticsearch
      blockinfile:
        path: "{{ elasticsearch_dir }}/config/elasticsearch.yml"
        block: |
          cluster.name: security-sandbox-cluster
          node.name: control-node
          network.host: 0.0.0.0
          http.port: 9200
          discovery.type: single-node
          xpack.security.enabled: true
          xpack.security.enrollment.enabled: false
          xpack.security.http.ssl.enabled: false
          xpack.security.transport.ssl.enabled: false
        marker: "# {mark} ANSIBLE MANAGED BLOCK"

    - name: Create Elasticsearch systemd service
      copy:
        dest: /etc/systemd/system/elasticsearch.service
        content: |
          [Unit]
          Description=Elasticsearch
          After=network.target

          [Service]
          Type=simple
          User=elasticsearch
          Group=elasticsearch
          ExecStart={{ elasticsearch_dir }}/bin/elasticsearch
          LimitNOFILE=65535
          LimitMEMLOCK=infinity

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes

    - name: Start Elasticsearch service
      systemd:
        name: elasticsearch
        state: started
        enabled: yes
      
    - name: Wait for Elasticsearch to be ready
      wait_for:
        port: 9200
        delay: 20
        timeout: 60

    - name: Reset elastic user password 
      command: "{{ elasticsearch_dir }}/bin/elasticsearch-reset-password -u elastic -b -f"
      register: elastic_password_output
      
    - name: Extract elastic password
      set_fact:
        elastic_password: "{{ elastic_password_output.stdout | regex_search('New value: (.+)', '\\1') | first }}"
      
    # Delete me after debugging
    - name: Display elastic password
      debug:
        msg: "Elasticsearch 'elastic' user password: {{ elastic_password }}"

    ############################################################################
    # PHASE 3: KIBANA AND PACKAGE REGISTRY INSTALLATION
    ############################################################################
    
    - name: Pull Package Registry Docker image
      docker_image:
        name: "docker.elastic.co/package-registry/distribution"
        tag: "{{ elastic_version }}"
        source: pull

    - name: Start Elastic Package Registry container
      docker_container:
        name: package-registry
        image: "docker.elastic.co/package-registry/distribution:{{ elastic_version }}"
        ports:
          - "{{ package_registry_port }}:8080"
        env:
          EPR_ADDRESS: "0.0.0.0:8080"
        restart_policy: unless-stopped
        state: started

    - name: Wait for Package Registry to be ready
      wait_for:
        port: "{{ package_registry_port }}"
        delay: 10
        timeout: 120

    - name: Create Kibana service account token
      uri:
        url: "http://localhost:9200/_security/service/elastic/kibana/credential/token/kibana-token"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: kibana_service_token
    
    - name: Download Kibana
      get_url:
        url: "https://artifacts.elastic.co/downloads/kibana/kibana-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/kibana.tar.gz"
        timeout: 600
      
    - name: Extract Kibana and set ownership
      unarchive:
        src: "/tmp/kibana.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "{{ kibana_dir }}"
        owner: kibana
        group: kibana
    
    - name: Generate Kibana encryption keys
      command: "{{ kibana_dir }}/bin/kibana-encryption-keys generate --force"
      register: kibana_keys_output

    - name: Parse Kibana encryption keys from generator output
      set_fact:
        kibana_encrypted_saved_objects_key: "{{ kibana_keys_output.stdout_lines | select('match', 'xpack.encryptedSavedObjects.encryptionKey: (.+)') | map('regex_replace', 'xpack.encryptedSavedObjects.encryptionKey: (.+)', '\\1') | first }}"
        kibana_reporting_key: "{{ kibana_keys_output.stdout_lines | select('match', 'xpack.reporting.encryptionKey: (.+)') | map('regex_replace', 'xpack.reporting.encryptionKey: (.+)', '\\1') | first }}"
        kibana_security_key: "{{ kibana_keys_output.stdout_lines | select('match', 'xpack.security.encryptionKey: (.+)') | map('regex_replace', 'xpack.security.encryptionKey: (.+)', '\\1') | first }}"
    
    - name: Configure Kibana
      blockinfile:
        path: "{{ kibana_dir }}/config/kibana.yml"
        block: |
          server.host: "0.0.0.0"
          server.port: 5601
          elasticsearch.hosts: ["http://{{ ansible_default_ipv4.address }}:9200"]
          elasticsearch.serviceAccountToken: "{{ kibana_service_token.json.token.value }}"
          
          # Encryption keys (must be stable across runs)
          xpack.encryptedSavedObjects.encryptionKey: "{{ kibana_encrypted_saved_objects_key }}"
          xpack.reporting.encryptionKey: "{{ kibana_reporting_key }}"
          xpack.security.encryptionKey: "{{ kibana_security_key }}"
          
          # Fleet air-gapped configuration (requires 8.13.0+)
          xpack.fleet.isAirGapped: true
          
          # Use local package registry
          xpack.fleet.registryUrl: "http://{{ ansible_default_ipv4.address }}:{{ package_registry_port }}"
          
          # Pre-configure Fleet Server host (avoids registry lookup)
          xpack.fleet.agents.fleet_server.hosts: ["http://{{ ansible_default_ipv4.address }}:8220"]
          
          # Pre-configure Elasticsearch output
          xpack.fleet.outputs:
          - id: fleet-default-output
            name: default
            type: elasticsearch
            hosts: ["http://localhost:9200"]
            is_default: true
            is_default_monitoring: true
          
          xpack.fleet.packages:
          - name: fleet_server
            version: latest
          - name: system
            version: latest
          - name: endpoint
            version: latest
          - name: osquery
            version: latest


    - name: Create Kibana systemd service
      copy:
        dest: /etc/systemd/system/kibana.service
        content: |
          [Unit]
          Description=Kibana
          After=network.target elasticsearch.service

          [Service]
          Type=simple
          User=kibana
          Group=kibana
          ExecStart={{ kibana_dir }}/bin/kibana

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Reload systemd daemon for Kibana
      systemd:
        daemon_reload: yes

    - name: Start/Restart Kibana 
      systemd:
        name: kibana
        state: restarted
        enabled: yes
      
    - name: Wait for Kibana to be ready
      wait_for:
        port: 5601
        delay: 10
        timeout: 60
        
    - name: Wait for Kibana license to be available
      uri:
        url: "{{ kibana_base_url }}/api/status"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
        status_code: 200
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: kibana_status
      retries: 20
      delay: 15
      until: kibana_status.status == 200 and kibana_status.json.status.overall.level == 'available'
      when: not (kibana_precheck is defined and kibana_precheck.status == 200 and kibana_precheck.json.status.overall.level == 'available')

    ############################################################################
    # SETUP DEFAULT AGENT POLICY
    ############################################################################

    - name: Enable Fleet in Kibana
      uri:
        url: "{{ kibana_base_url }}/api/fleet/setup"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        timeout: 300
        status_code: 200
        return_content: yes
      register: fleet_setup

    - name: Create Fleet Server policy
      uri:
       url: "{{ kibana_base_url }}/api/fleet/agent_policies"
       method: POST
       user: elastic
       password: "{{ elastic_password }}"
       force_basic_auth: yes
       headers:
         kbn-xsrf: "true"
         Content-Type: "application/json"
       body_format: json
       body:
         id: "fleet-server-policy"
         name: "Fleet Server policy"
         namespace: "default"
         description: "Fleet Server policy (created by Ansible)"
         monitoring_enabled: ["logs", "metrics"]
         has_fleet_server: true
       status_code: 200
      register: fleet_policy_resp

    - name: Set Fleet Server policy id fact
      set_fact:
        fleet_server_policy_id: "fleet-server-policy"

    - name: Get fleet_server package details (resolve version)
      uri:
        url: "{{ kibana_base_url }}/api/fleet/epm/packages/fleet_server"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
        return_content: yes
        status_code: 200
      register: fleet_server_pkg

    - name: Set fleet_server package version fact
      set_fact:
        fleet_server_pkg_version: "{{ fleet_server_pkg.json.item.version | default('') }}"

    - name: Add Fleet Server Integration to Fleet Server Policy
      uri:
        url: "{{ kibana_base_url }}/api/fleet/package_policies"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "Fleet Server"
          description: "Fleet Server Integration"
          policy_id: "{{ fleet_server_policy_id }}"
          package:
            name: "fleet_server"
            version: "{{ fleet_server_pkg_version | default('') if fleet_server_pkg_version | length > 0 else 'latest' }}"
        return_content: yes
        status_code: 201
      register: fleet_server_integration_result

    - name: Create Default Agent Policy
      uri:
        url: "{{ kibana_base_url }}/api/fleet/agent_policies"
        method: POST
        user: "elastic"
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "Default Agent Policy"
          description: "Created via Ansible"
          namespace: "default"
          monitoring_enabled:
            - logs
            - metrics
        return_content: yes
        status_code: 201
      register: fleet_policy

    - name: Set default policy id from creation
      set_fact:
        default_policy_id: "{{ fleet_policy.json.item.id }}"



    ############################################################################
    # PHASE 4: FLEET SERVER INSTALLATION
    ############################################################################
    
    - name: Create Fleet service token
      uri:
        url: "http://localhost:9200/_security/service/elastic/fleet-server/credential/token/fleet-token"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: fleet_service_token
      
    - name: Download Elastic Agent
      get_url:
        url: "https://artifacts.elastic.co/downloads/beats/elastic-agent/elastic-agent-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/elastic-agent.tar.gz"
        timeout: 600
      
    - name: Extract Elastic Agent
      unarchive:
        src: "/tmp/elastic-agent.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "/opt/elastic-agent-{{ elastic_version }}-linux-x86_64"
      
    - name: Install Fleet Server
      shell: |
        cd /opt/elastic-agent-{{ elastic_version }}-linux-x86_64
        ./elastic-agent install \
          --url={{ kibana_base_url }} \
          --fleet-server-es=http://localhost:9200 \
          --fleet-server-service-token={{ fleet_service_token.json.token.value }} \
          --fleet-server-policy={{ fleet_server_policy_id }} \
          --fleet-server-host=0.0.0.0 \
          --fleet-server-port=8220 \
          --fleet-server-insecure-http \
          --non-interactive
      
    - name: Wait for Fleet Server to be ready
      wait_for:
        port: 8220
        delay: 10
        timeout: 60

    - name: Create Fleet enrollment API key
      uri:
        url: "{{ kibana_base_url }}/api/fleet/enrollment_api_keys"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "auto-enroll"
          policy_id: "{{ fleet_server_policy_id }}"
          expiration: "1d"
        status_code: 201
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: fleet_enrollment_response

    - name: Set enrollment token from created key
      set_fact:
        fleet_enrollment_token: "{{ fleet_enrollment_response.json.item.api_key }}"

    - name: Create enrollment token for Default Policy
      uri:
        url: "{{ kibana_base_url }}/api/fleet/enrollment_api_keys"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "default-policy-enroll"
          policy_id: "{{ default_policy_id }}"
          expiration: "7d"
        status_code: 201
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: default_policy_enrollment_response

    - name: Set default policy enrollment token (for target machines)
      set_fact:
        default_policy_enrollment_token: "{{ default_policy_enrollment_response.json.item.api_key }}"

    ############################################################################
    # PHASE 5: DISPLAY CREDENTIALS
    ############################################################################
    - name: Save Fleet credentials to local file
      copy:
        content: |
          # Fleet Server Credentials for Target Machine Enrollment
          # Generated: {{ ansible_date_time.iso8601 }}
          # Control Server: {{ ansible_default_ipv4.address }}
          
          fleet_url: "http://{{ ansible_default_ipv4.address }}:8220"
          fleet_enrollment_token: "{{ default_policy_enrollment_token | default(fleet_enrollment_token) }}"
          fleet_server_enrollment_token: "{{ fleet_enrollment_token }}"
          elasticsearch_host: "http://{{ ansible_default_ipv4.address }}:9200"
          elastic_username: "elastic"
          elastic_password: "{{ elastic_password }}"
          kibana_host: "http://{{ ansible_default_ipv4.address }}:5601"
        dest: "{{ playbook_dir }}/.fleet_credentials.yml"
      delegate_to: localhost
      become: no
      
    - name: Display deployment summary
      debug:
        msg: |
          ============================================================
          ✅ CONTROL INSTANCE DEPLOYMENT COMPLETE
          ============================================================
          
          Services Running:
          - Elasticsearch: http://{{ ansible_default_ipv4.address }}:9200
          - Kibana:        http://{{ ansible_default_ipv4.address }}:5601
          - Fleet Server:  http://{{ ansible_default_ipv4.address }}:8220
          - Package Registry: http://{{ ansible_default_ipv4.address }}:{{ package_registry_port }}
          
          Credentials:
          - Username: elastic
          - Password: {{ elastic_password }}
          
          Fleet Enrollment Token:
          {{ fleet_enrollment_token }}
          
          FLEET SERVER ENROLLMENT DETAILS (Save these for target machines):
          -----------------------------------------------------------
          fleet_url: "http://{{ ansible_default_ipv4.address }}:8220"
          fleet_enrollment_token: "{{ fleet_enrollment_token }}"
          elasticsearch_host: "http://{{ ansible_default_ipv4.address }}:9200"
          elastic_username: "elastic"
          elastic_password: "{{ elastic_password }}"
          kibana_host: "http://{{ ansible_default_ipv4.address }}:5601"
          -----------------------------------------------------------
          
          Next Steps:
          1. Access Kibana: http://{{ ansible_default_ipv4.address }}:5601
          2. Login with elastic/{{ elastic_password }}
          3. Go to Management → Fleet to verify Fleet Server
          4. Deploy target machines using saved credentials
                    
          ============================================================

    ############################################################################
    # PHASE 6: CLEANUP
    ############################################################################
    
    - name: Remove temporary downloaded files
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/tmp/elasticsearch.tar.gz"
        - "/tmp/kibana.tar.gz"
        - "/tmp/elastic-agent.tar.gz"

    - name: Display cleanup summary
      debug:
        msg: |
          ============================================================
           CLEANUP COMPLETE
          ============================================================
          
          Removed temporary files from logging server:
          - /tmp/elasticsearch.tar.gz
          - /tmp/kibana.tar.gz  
          - /tmp/elastic-agent.tar.gz

          ============================================================
