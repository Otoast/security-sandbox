
- name: Control Machine Setup - ELK Stack
  hosts: logging_server
  become: yes
  vars:
    elastic_version: "8.11.0"
    elasticsearch_dir: "/opt/elasticsearch-{{ elastic_version }}"
    kibana_dir: "/opt/kibana-{{ elastic_version }}"
    # Download cache on Ansible controller (attacker machine)
    local_cache_dir: "{{ playbook_dir }}/downloads"
    # Kibana / Fleet connection settings
    kibana_base_url: "http://localhost:5601"
    kibana_request_timeout: 60
    fleet_api_retries: 10
    fleet_api_delay: 10

  tasks:
    ############################################################################
    # PHASE 0: DOWNLOAD FILES ON CONTROLLER (ATTACKER MACHINE)
    ############################################################################
    
    - name: Ensure downloads directory exists on controller
      local_action: file path="{{ local_cache_dir }}" state=directory
      become: no
      run_once: true

    - name: Download Elasticsearch on controller
      local_action: get_url url="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-{{ elastic_version }}-linux-x86_64.tar.gz" dest="{{ local_cache_dir }}/elasticsearch-{{ elastic_version }}-linux-x86_64.tar.gz" timeout=600
      become: no
      run_once: true

    ############################################################################
    # PHASE 1: SYSTEM PREPARATION
    ############################################################################
    
    - name: Set kernel parameters for Elasticsearch
      sysctl:
        name: vm.max_map_count
        value: '262144'
        state: present
        reload: yes

    - name: Create elasticsearch system user
      user:
        name: elasticsearch
        system: yes
        shell: /bin/bash
        home: /opt/elasticsearch
        create_home: no

    - name: Create kibana system user
      user:
        name: kibana
        system: yes
        shell: /bin/bash
        home: /opt/kibana
        create_home: no

    ############################################################################
    # PHASE 2: ELASTICSEARCH INSTALLATION
    ############################################################################
    
    - name: Copy Elasticsearch to control machine
      copy:
        src: "{{ local_cache_dir }}/elasticsearch-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/elasticsearch.tar.gz"
      
    - name: Extract Elasticsearch
      unarchive:
        src: "/tmp/elasticsearch.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "{{ elasticsearch_dir }}"

    - name: Set ownership of Elasticsearch directory
      file:
        path: "{{ elasticsearch_dir }}"
        owner: elasticsearch
        group: elasticsearch
        recurse: yes

    - name: Configure Elasticsearch
      blockinfile:
        path: "{{ elasticsearch_dir }}/config/elasticsearch.yml"
        block: |
          cluster.name: security-sandbox-cluster
          node.name: control-node
          network.host: 0.0.0.0
          http.port: 9200
          discovery.type: single-node
          xpack.security.enabled: true
          xpack.security.enrollment.enabled: false
          xpack.security.http.ssl.enabled: false
          xpack.security.transport.ssl.enabled: false
        marker: "# {mark} ANSIBLE MANAGED BLOCK"

    - name: Create Elasticsearch systemd service
      copy:
        dest: /etc/systemd/system/elasticsearch.service
        content: |
          [Unit]
          Description=Elasticsearch
          After=network.target

          [Service]
          Type=simple
          User=elasticsearch
          Group=elasticsearch
          ExecStart={{ elasticsearch_dir }}/bin/elasticsearch
          LimitNOFILE=65535
          LimitMEMLOCK=infinity

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes

    - name: Start Elasticsearch service
      systemd:
        name: elasticsearch
        state: started
        enabled: yes
      
    - name: Wait for Elasticsearch to be ready
      wait_for:
        port: 9200
        delay: 20
        timeout: 300
      
    - name: Additional wait for Elasticsearch startup
      pause:
        seconds: 10

    - name: Reset elastic user password
      command: "{{ elasticsearch_dir }}/bin/elasticsearch-reset-password -u elastic -b"
      register: elastic_password_output
      
    - name: Extract elastic password
      set_fact:
        elastic_password: "{{ elastic_password_output.stdout | regex_search('New value: (.+)', '\\1') | first }}"
      
    - name: Display elastic password
      debug:
        msg: "Elasticsearch 'elastic' user password: {{ elastic_password }}"

    ############################################################################
    # PHASE 3: KIBANA INSTALLATION
    ############################################################################
    
    - name: Download Kibana on controller
      local_action: get_url url="https://artifacts.elastic.co/downloads/kibana/kibana-{{ elastic_version }}-linux-x86_64.tar.gz" dest="{{ local_cache_dir }}/kibana-{{ elastic_version }}-linux-x86_64.tar.gz" timeout=600
      become: no
      run_once: true

    - name: Check if Kibana service token exists
      uri:
        url: "http://localhost:9200/_security/service/elastic/kibana/credential"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: existing_tokens
      failed_when: false

    - name: Delete existing Kibana token if present
      uri:
        url: "http://localhost:9200/_security/service/elastic/kibana/credential/token/kibana-token"
        method: DELETE
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: [200, 404]
      when: existing_tokens.json['tokens'] is defined and ('kibana-token' in existing_tokens.json['tokens'])
      failed_when: false

    - name: Create Kibana service account token
      uri:
        url: "http://localhost:9200/_security/service/elastic/kibana/credential/token/kibana-token"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: kibana_service_token
    
    - name: Copy Kibana to control machine
      copy:
        src: "{{ local_cache_dir }}/kibana-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/kibana.tar.gz"
      
    - name: Extract Kibana
      unarchive:
        src: "/tmp/kibana.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "{{ kibana_dir }}"

    - name: Set ownership of Kibana directory
      file:
        path: "{{ kibana_dir }}"
        owner: kibana
        group: kibana
        recurse: yes

    - name: Configure Kibana
      blockinfile:
        path: "{{ kibana_dir }}/config/kibana.yml"
        block: |
          server.host: "0.0.0.0"
          server.port: 5601
          elasticsearch.hosts: ["http://localhost:9200"]
          elasticsearch.serviceAccountToken: "{{ kibana_service_token.json.token.value }}"
        marker: "# {mark} ANSIBLE MANAGED BLOCK"

    - name: Create Kibana systemd service
      copy:
        dest: /etc/systemd/system/kibana.service
        content: |
          [Unit]
          Description=Kibana
          After=network.target elasticsearch.service

          [Service]
          Type=simple
          User=kibana
          Group=kibana
          ExecStart={{ kibana_dir }}/bin/kibana

          [Install]
          WantedBy=multi-user.target
        mode: '0644'

    - name: Reload systemd daemon for Kibana
      systemd:
        daemon_reload: yes

    - name: Restart Kibana service
      systemd:
        name: kibana
        state: restarted
        enabled: yes
      
    - name: Wait for Kibana to be ready
      wait_for:
        port: 5601
        delay: 30
        timeout: 300

    - name: Additional wait for Kibana initialization
      pause:
        seconds: 20
        prompt: "Waiting for Kibana to fully initialize Fleet policies..."

    - name: Wait for Kibana license to be available
      uri:
        url: "{{ kibana_base_url }}/api/status"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
        status_code: 200
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: kibana_status
      retries: 20
      delay: 15
      until: kibana_status.status == 200 and kibana_status.json.status.overall.level == 'available'

    - name: Enable Fleet in Kibana
      uri:
        url: "{{ kibana_base_url }}/api/fleet/setup"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        timeout: "{{ kibana_request_timeout }}"
        status_code: 200
        return_content: yes
      register: fleet_setup
      failed_when: false

    - name: Wait for Fleet to initialize
      pause:
        seconds: 10
        prompt: "Waiting for Fleet to fully initialize..."

    - name: Get Fleet Server policy
      uri:
        url: "{{ kibana_base_url }}/api/fleet/agent_policies"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
        status_code: 200
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: fleet_policies
      retries: 10
      delay: 10
      until: fleet_policies.status == 200

    - name: Set default policy facts
      set_fact:
        fleet_server_policy_exists: false
        fleet_server_policy_id: ""

    - name: Find Fleet Server policy
      set_fact:
        fleet_server_policy_exists: true
        fleet_server_policy_id: "{{ item.id }}"
      loop: "{{ fleet_policies.json['items'] | default([]) }}"
      when: 
        - fleet_policies.json['items'] is defined
        - item.name is defined
        - item.name == 'Fleet Server policy'

    - name: Create Fleet Server policy if it doesn't exist
      uri:
        url: "{{ kibana_base_url }}/api/fleet/agent_policies"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "Fleet Server policy"
          namespace: "default"
          description: "Fleet Server policy"
          monitoring_enabled:
            - logs
            - metrics
          has_fleet_server: true
        status_code: [200, 201, 409]
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: fleet_server_policy_created
      failed_when: false
      when: not fleet_server_policy_exists
      retries: "{{ fleet_api_retries }}"
      delay: "{{ fleet_api_delay }}"
      until: fleet_server_policy_created.status in [200, 201, 409]

    - name: Get Fleet Server policy ID
      set_fact:
        fleet_server_policy_id: "{{ (fleet_policies.json['items'] | selectattr('name', 'equalto', 'Fleet Server policy') | list | first).id if fleet_server_policy_exists else fleet_server_policy_created.json.item.id }}"

    - name: Add Fleet Server integration to policy
      uri:
        url: "{{ kibana_base_url }}/api/fleet/package_policies"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "fleet_server-1"
          namespace: "default"
          policy_id: "{{ fleet_server_policy_id }}"
          enabled: true
          package:
            name: "fleet_server"
            version: "1.5.0"
          inputs:
            - type: "fleet-server"
              enabled: true
              streams: []
              vars:
                host:
                  value: "0.0.0.0"
                  type: "text"
                port:
                  value: 8220
                  type: "integer"
                custom: ""
        status_code: [200, 201, 409]
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: fleet_server_integration
      failed_when: false
      retries: "{{ fleet_api_retries }}"
      delay: "{{ fleet_api_delay }}"
      until: fleet_server_integration.status in [200, 201, 409]

    ############################################################################
    # PHASE 4: FLEET SERVER INSTALLATION
    ############################################################################
    
    - name: Check if Fleet service token exists
      uri:
        url: "http://localhost:9200/_security/service/elastic/fleet-server/credential"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: existing_fleet_tokens
      failed_when: false

    - name: Delete existing Fleet token if present
      uri:
        url: "http://localhost:9200/_security/service/elastic/fleet-server/credential/token/fleet-token"
        method: DELETE
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: [200, 404]
      when: existing_fleet_tokens.json['tokens'] is defined and ('fleet-token' in existing_fleet_tokens.json['tokens'])
      failed_when: false

    - name: Create Fleet service token
      uri:
        url: "http://localhost:9200/_security/service/elastic/fleet-server/credential/token/fleet-token"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        status_code: 200
        return_content: yes
      register: fleet_service_token
      
    - name: Download Elastic Agent on controller
      local_action: get_url url="https://artifacts.elastic.co/downloads/beats/elastic-agent/elastic-agent-{{ elastic_version }}-linux-x86_64.tar.gz" dest="{{ local_cache_dir }}/elastic-agent-{{ elastic_version }}-linux-x86_64.tar.gz" timeout=600
      become: no
      run_once: true

    - name: Copy Elastic Agent to control machine
      copy:
        src: "{{ local_cache_dir }}/elastic-agent-{{ elastic_version }}-linux-x86_64.tar.gz"
        dest: "/tmp/elastic-agent.tar.gz"
      
    - name: Extract Elastic Agent
      unarchive:
        src: "/tmp/elastic-agent.tar.gz"
        dest: "/opt/"
        remote_src: yes
        creates: "/opt/elastic-agent-{{ elastic_version }}-linux-x86_64"
      
    - name: Install Fleet Server
      shell: |
        cd /opt/elastic-agent-{{ elastic_version }}-linux-x86_64
        ./elastic-agent install \
          --url={{ kibana_base_url }} \
          --fleet-server-es=http://localhost:9200 \
          --fleet-server-service-token={{ fleet_service_token.json.token.value }} \
          --fleet-server-policy={{ fleet_server_policy_id }} \
          --fleet-server-insecure-http \
          --non-interactive
      args:
        creates: /opt/Elastic/Agent/elastic-agent
      
    - name: Wait for Fleet Server to be ready
      wait_for:
        port: 8220
        delay: 10
        timeout: 180

    - name: Get Fleet enrollment API key list
      uri:
        url: "{{ kibana_base_url }}/api/fleet/enrollment_api_keys"
        method: GET
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
        status_code: 200
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: existing_enrollment_keys
      failed_when: false

    - name: Set default enrollment facts
      set_fact:
        fleet_enrollment_token: ""
        fleet_enrollment_key_found: false

    - name: Find existing enrollment key for policy
      set_fact:
        fleet_enrollment_token: "{{ item.api_key }}"
        fleet_enrollment_key_found: true
      loop: "{{ existing_enrollment_keys.json['list'] | default([]) }}"
      when:
        - item.name is defined
        - item.policy_id is defined
        - "'auto-enroll' in item.name"
        - item.policy_id == fleet_server_policy_id

    - name: Create Fleet enrollment API key if missing
      uri:
        url: "{{ kibana_base_url }}/api/fleet/enrollment_api_keys"
        method: POST
        user: elastic
        password: "{{ elastic_password }}"
        force_basic_auth: yes
        headers:
          kbn-xsrf: "true"
          Content-Type: "application/json"
        body_format: json
        body:
          name: "auto-enroll"
          policy_id: "{{ fleet_server_policy_id }}"
          expiration: "1d"
        status_code: [200, 201]
        return_content: yes
        timeout: "{{ kibana_request_timeout }}"
      register: fleet_enrollment_response
      when: not fleet_enrollment_key_found
      failed_when: false

    - name: Set enrollment token from created key if created
      set_fact:
        fleet_enrollment_token: "{{ fleet_enrollment_response.json.item.api_key }}"
      when: fleet_enrollment_response is defined and fleet_enrollment_response.json.item.api_key is defined

    ############################################################################
    # PHASE 5: DISPLAY CREDENTIALS
    ############################################################################
    - name: Save Fleet credentials to local file
      copy:
        content: |
          # Fleet Server Credentials for Target Machine Enrollment
          # Generated: {{ ansible_date_time.iso8601 }}
          # Control Server: {{ ansible_default_ipv4.address }}
          
          fleet_url: "http://{{ ansible_default_ipv4.address }}:8220"
          fleet_enrollment_token: "{{ fleet_enrollment_token }}"
          elasticsearch_host: "http://{{ ansible_default_ipv4.address }}:9200"
          elastic_username: "elastic"
          elastic_password: "{{ elastic_password }}"
          kibana_host: "http://{{ ansible_default_ipv4.address }}:5601"
        dest: "{{ playbook_dir }}/.fleet_credentials.yml"
      delegate_to: localhost
      become: no
      
    - name: Display deployment summary
      debug:
        msg: |
          ============================================================
          âœ… CONTROL INSTANCE DEPLOYMENT COMPLETE
          ============================================================
          
          Services Running:
          - Elasticsearch: http://{{ ansible_default_ipv4.address }}:9200
          - Kibana:        http://{{ ansible_default_ipv4.address }}:5601
          - Fleet Server:  http://{{ ansible_default_ipv4.address }}:8220
          
          Credentials:
          - Username: elastic
          - Password: {{ elastic_password }}
          
          Fleet Enrollment Token:
          {{ fleet_enrollment_token }}
          
          FLEET SERVER ENROLLMENT DETAILS (Save these for target machines):
          -----------------------------------------------------------
          fleet_url: "http://{{ ansible_default_ipv4.address }}:8220"
          fleet_enrollment_token: "{{ fleet_enrollment_token }}"
          elasticsearch_host: "http://{{ ansible_default_ipv4.address }}:9200"
          elastic_username: "elastic"
          elastic_password: "{{ elastic_password }}"
          kibana_host: "http://{{ ansible_default_ipv4.address }}:5601"
          -----------------------------------------------------------
          
          Next Steps:
          1. Access Kibana: http://{{ ansible_default_ipv4.address }}:5601
          2. Login with elastic/{{ elastic_password }}
          3. Go to Management â†’ Fleet to verify Fleet Server
          4. Deploy target machines using saved credentials
                    
          ============================================================

    ############################################################################
    # PHASE 6: CLEANUP
    ############################################################################
    
    - name: Remove temporary downloaded tarballs from target machine
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/tmp/elasticsearch.tar.gz"
        - "/tmp/kibana.tar.gz"
        - "/tmp/elastic-agent.tar.gz"

    - name: Display cleanup summary
      debug:
        msg: |
          ============================================================
          ðŸ§¹ CLEANUP COMPLETE
          ============================================================
          
          Removed temporary files from target machine:
          - /tmp/elasticsearch.tar.gz
          - /tmp/kibana.tar.gz  
          - /tmp/elastic-agent.tar.gz
          
          Note: Downloaded files on controller are kept at:
          {{ local_cache_dir }}
          (Useful for re-deploying without re-downloading)
          
          To clean controller cache, run:
          rm -rf {{ local_cache_dir }}
          
          ============================================================
